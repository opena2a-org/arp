name: PR Review

on:
  pull_request:
    branches: [main]
    types: [opened, synchronize]

concurrency:
  group: pr-review-${{ github.event.pull_request.number }}
  cancel-in-progress: true

permissions:
  pull-requests: write
  contents: read

jobs:
  review:
    name: Claude Code Review
    runs-on: ubuntu-latest
    env:
      PR_NUMBER: ${{ github.event.pull_request.number }}
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Gather review context
        id: context
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          gh pr diff "$PR_NUMBER" > /tmp/pr_diff.txt
          gh pr diff "$PR_NUMBER" --name-only > /tmp/changed_files.txt
          gh pr view "$PR_NUMBER" --json title -q '.title' > /tmp/pr_title.txt
          gh pr view "$PR_NUMBER" --json body -q '.body' | head -c 2000 > /tmp/pr_body.txt

          DIFF_BYTES=$(wc -c < /tmp/pr_diff.txt | tr -d ' ')
          echo "$DIFF_BYTES" > /tmp/diff_size.txt
          FILE_COUNT=$(wc -l < /tmp/changed_files.txt | tr -d ' ')
          echo "$FILE_COUNT" > /tmp/file_count.txt

          if [ "$DIFF_BYTES" -gt 120000 ]; then
            head -c 120000 /tmp/pr_diff.txt > /tmp/pr_diff_trunc.txt
            printf '\n\n[DIFF TRUNCATED — original was %s bytes]\n' "$DIFF_BYTES" >> /tmp/pr_diff_trunc.txt
            mv /tmp/pr_diff_trunc.txt /tmp/pr_diff.txt
          fi

          echo "" > /tmp/full_files.txt
          TOTAL_SIZE=0
          MAX_FULL_SIZE=200000
          while IFS= read -r file; do
            case "$file" in
              *.test.* | *.spec.* | package-lock.json | *.lock) continue ;;
            esac
            [ -f "$file" ] || continue
            FILE_SIZE=$(wc -c < "$file" | tr -d ' ')
            NEW_TOTAL=$((TOTAL_SIZE + FILE_SIZE))
            if [ "$NEW_TOTAL" -gt "$MAX_FULL_SIZE" ]; then
              printf '\n[FULL FILE CONTEXT TRUNCATED at %s bytes]\n' "$TOTAL_SIZE" >> /tmp/full_files.txt
              break
            fi
            TOTAL_SIZE=$NEW_TOTAL
            printf '\n=== %s ===\n' "$file" >> /tmp/full_files.txt
            nl -ba "$file" >> /tmp/full_files.txt
          done < /tmp/changed_files.txt

          gh api "repos/${{ github.repository }}/pulls/$PR_NUMBER/reviews" \
            --jq '[.[] | select(.body | test("Claude Code Review")) | .body] | last // ""' \
            2>/dev/null | head -c 4000 > /tmp/previous_review.txt || echo "" > /tmp/previous_review.txt

      - name: Run Claude review
        id: review
        env:
          ANTHROPIC_API_KEY: ${{ secrets.ANTHROPIC_API_KEY }}
        run: |
          PR_TITLE=$(cat /tmp/pr_title.txt)

          cat > /tmp/system_prompt.txt << 'SYSPROMPT'
          You are a senior security engineer reviewing a pull request for ARP (Agent Runtime Protection) — a runtime security monitoring library for AI agents built in TypeScript/Node.js.

          ARP monitors process spawns, network connections, and filesystem access using OS-level polling (ps, lsof, fs.watch) and zero-latency Node.js built-in module interception (child_process, net, fs). It has a 3-layer intelligence stack: L0 rules, L1 z-score anomaly detection, L2 LLM-assisted assessment with budget control.

          You have TWO sources of information:
          1. FULL SOURCE FILES — complete line-numbered source code of changed files (use this to VERIFY mitigations)
          2. DIFF — the actual changes introduced in this PR

          Review focus (in priority order):
          1. SECURITY: Module hooking safety, prototype pollution, monkey-patching side effects, event emission loops, resource leaks, signal handling safety, path traversal in monitors
          2. CORRECTNESS: Async/await correctness, EventEmitter patterns, process lifecycle management, timer cleanup, race conditions between monitors and interceptors
          3. QUALITY: Breaking API changes, missing error handling at system boundaries, unvalidated external input

          === VERIFICATION MANDATE ===
          For EVERY potential finding, you MUST:
          1. Identify the vulnerability pattern and location
          2. Search the FULL SOURCE FILE for mitigations
          3. Check for validation, guards, or error handling nearby
          4. ONLY report if NO adequate mitigation exists

          === COMMON FALSE POSITIVES — DO NOT REPORT ===
          - Monkey-patching when original functions are stored and restored in stop()
          - Signal handling (SIGSTOP/SIGTERM/SIGKILL) — this is the enforcement layer, it is intentional
          - Child process killing — this is the kill-switch feature, it is intentional
          - fs.watch recursive flag — platform-specific, handled with try/catch
          - execSync for lsof/ss/netstat — these are read-only system queries, not user-controlled

          === RE-REVIEW AWARENESS ===
          If a PREVIOUS REVIEW is included, check whether flagged issues were fixed. Do NOT re-raise mitigated findings.

          Response format (strict):
          VERDICT: APPROVE or REQUEST_CHANGES
          SUMMARY: One paragraph.
          FINDINGS:
          - [CRITICAL|HIGH|MEDIUM] path/file.ts:line — Description. Mitigation check: [what you looked for]
          (omit FINDINGS section if none)

          Rules:
          - APPROVE if no CRITICAL or HIGH findings remain
          - Only REQUEST_CHANGES for genuine unmitigated issues in this PR
          - CI/config/docs-only changes: always APPROVE
          - Max 10 findings
          SYSPROMPT

          {
            printf 'PR #%s: %s\n\nDescription:\n' "$PR_NUMBER" "$PR_TITLE"
            cat /tmp/pr_body.txt
            printf '\n\nChanged files:\n'
            cat /tmp/changed_files.txt
            printf '\n\nFULL SOURCE FILES (line-numbered):\n'
            cat /tmp/full_files.txt
            printf '\n\nDIFF:\n'
            cat /tmp/pr_diff.txt
          } > /tmp/user_msg.txt

          if [ -s /tmp/previous_review.txt ] && [ "$(wc -c < /tmp/previous_review.txt | tr -d ' ')" -gt 10 ]; then
            printf '\n\nPREVIOUS REVIEW:\n' >> /tmp/user_msg.txt
            cat /tmp/previous_review.txt >> /tmp/user_msg.txt
          fi

          RESPONSE=$(jq -n \
            --rawfile system /tmp/system_prompt.txt \
            --rawfile user /tmp/user_msg.txt \
            '{
              model: "claude-sonnet-4-5-20250929",
              max_tokens: 16000,
              thinking: { type: "enabled", budget_tokens: 10000 },
              system: $system,
              messages: [{ role: "user", content: $user }]
            }' | curl -s -X POST "https://api.anthropic.com/v1/messages" \
              -H "Content-Type: application/json" \
              -H "x-api-key: ${ANTHROPIC_API_KEY}" \
              -H "anthropic-version: 2025-04-15" \
              -d @-)

          REVIEW_TEXT=$(echo "$RESPONSE" | jq -r '[.content[] | select(.type == "text") | .text] | join("\n") // empty')

          if [ -z "$REVIEW_TEXT" ]; then
            RESPONSE=$(jq -n \
              --rawfile system /tmp/system_prompt.txt \
              --rawfile user /tmp/user_msg.txt \
              '{
                model: "claude-sonnet-4-5-20250929",
                max_tokens: 8192,
                system: $system,
                messages: [{ role: "user", content: $user }]
              }' | curl -s -X POST "https://api.anthropic.com/v1/messages" \
                -H "Content-Type: application/json" \
                -H "x-api-key: ${ANTHROPIC_API_KEY}" \
                -H "anthropic-version: 2023-06-01" \
                -d @-)
            REVIEW_TEXT=$(echo "$RESPONSE" | jq -r '.content[0].text // empty')
          fi

          if [ -z "$REVIEW_TEXT" ]; then
            ERROR=$(echo "$RESPONSE" | jq -r '.error.message // "Unknown API error"')
            echo "::error::Claude API call failed: $ERROR"
            exit 1
          else
            echo "$REVIEW_TEXT" > /tmp/review_body.txt
            VERDICT=$(grep -oP 'VERDICT:\s*\K(APPROVE|REQUEST_CHANGES)' /tmp/review_body.txt | head -1)
            echo "${VERDICT:-APPROVE}" > /tmp/verdict.txt
          fi

      - name: Post review
        if: always() && steps.review.outcome != 'skipped'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          VERDICT=$(cat /tmp/verdict.txt 2>/dev/null || echo "APPROVE")
          DIFF_SIZE=$(cat /tmp/diff_size.txt)
          FILE_COUNT=$(cat /tmp/file_count.txt)

          {
            echo "## Claude Code Review"
            echo ""
            cat /tmp/review_body.txt
            echo ""
            echo "---"
            echo "*Reviewed ${FILE_COUNT} files changed (${DIFF_SIZE} bytes)*"
          } > /tmp/full_review.txt

          BODY=$(cat /tmp/full_review.txt)

          if [ "$VERDICT" = "REQUEST_CHANGES" ]; then
            gh pr review "$PR_NUMBER" --request-changes --body "$BODY" 2>/dev/null || \
              gh pr comment "$PR_NUMBER" --body "$BODY"
          else
            gh pr review "$PR_NUMBER" --approve --body "$BODY" 2>/dev/null || \
              gh pr comment "$PR_NUMBER" --body "$BODY"
          fi

      - name: Enforce verdict
        run: |
          VERDICT=$(cat /tmp/verdict.txt 2>/dev/null || echo "APPROVE")
          if [ "$VERDICT" = "REQUEST_CHANGES" ]; then
            echo "::error::Review found CRITICAL/HIGH issues that must be resolved before merge."
            exit 1
          fi
